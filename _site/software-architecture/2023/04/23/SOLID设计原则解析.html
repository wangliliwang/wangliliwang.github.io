<!DOCTYPE html>
<html lang="en"><head>
  <meta charset="utf-8" />
  <meta http-equiv="X-UA-Compatible" content="IE=edge" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />

  <title>SOLID设计原则解析</title><!-- Begin Jekyll SEO tag v2.8.0 -->
<meta name="generator" content="Jekyll v3.9.3" />
<meta property="og:title" content="SOLID设计原则解析" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="SOLID设计原则" />
<meta property="og:description" content="SOLID设计原则" />
<link rel="canonical" href="http://localhost:4000/software-architecture/2023/04/23/SOLID%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99%E8%A7%A3%E6%9E%90.html" />
<meta property="og:url" content="http://localhost:4000/software-architecture/2023/04/23/SOLID%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99%E8%A7%A3%E6%9E%90.html" />
<meta property="og:site_name" content="Wangli’s Programming Blog" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2023-04-23T17:43:49+08:00" />
<meta name="twitter:card" content="summary" />
<meta property="twitter:title" content="SOLID设计原则解析" />
<script type="application/ld+json">
{"@context":"https://schema.org","@type":"BlogPosting","dateModified":"2023-04-23T17:43:49+08:00","datePublished":"2023-04-23T17:43:49+08:00","description":"SOLID设计原则","headline":"SOLID设计原则解析","mainEntityOfPage":{"@type":"WebPage","@id":"http://localhost:4000/software-architecture/2023/04/23/SOLID%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99%E8%A7%A3%E6%9E%90.html"},"url":"http://localhost:4000/software-architecture/2023/04/23/SOLID%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99%E8%A7%A3%E6%9E%90.html"}</script>
<!-- End Jekyll SEO tag -->
<link type="application/atom+xml" rel="alternate" href="http://localhost:4000/feed.xml" title="Wangli&apos;s Programming Blog" /><link rel="shortcut icon" type="image/x-icon" href="" />
  <link rel="stylesheet" href="/assets/css/main.css" />
</head><body a="auto">
    <main class="page-content" aria-label="Content">
      <div class="w">
        <a href="/">..</a><article>
    <p class="post-meta">
        <time datetime="2023-04-23 17:43:49 +0800">2023-04-23</time>
    </p>

    <h1>SOLID设计原则解析</h1>

    <h2>Table Of Contents</h2>

    <div id="table-of-contents">
        <ul id="toc" class="section-nav">
<li class="toc-entry toc-h2"><a href="#-solid%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99-"> SOLID设计原则 </a>
<ul>
<li class="toc-entry toc-h3"><a href="#single-responsibility-principle-单一职责原则">Single Responsibility Principle 单一职责原则</a>
<ul>
<li class="toc-entry toc-h4"><a href="#例子">例子</a></li>
<li class="toc-entry toc-h4"><a href="#原则阐述">原则阐述</a></li>
</ul>
</li>
<li class="toc-entry toc-h3"><a href="#open-closed-principle-开闭原则">Open Closed Principle 开闭原则</a>
<ul>
<li class="toc-entry toc-h4"><a href="#例子-1">例子</a></li>
<li class="toc-entry toc-h4"><a href="#原则阐述-1">原则阐述</a></li>
</ul>
</li>
<li class="toc-entry toc-h3"><a href="#liskov-substitution-principle-里氏替换原则">Liskov Substitution Principle 里氏替换原则</a>
<ul>
<li class="toc-entry toc-h4"><a href="#例子-2">例子</a></li>
<li class="toc-entry toc-h4"><a href="#原则阐述-2">原则阐述</a></li>
</ul>
</li>
<li class="toc-entry toc-h3"><a href="#interface-segregation-principle-接口隔离原则">Interface Segregation Principle 接口隔离原则</a>
<ul>
<li class="toc-entry toc-h4"><a href="#例子-3">例子</a></li>
<li class="toc-entry toc-h4"><a href="#原则阐述-3">原则阐述</a></li>
</ul>
</li>
<li class="toc-entry toc-h3"><a href="#dependency-inversion-principle-依赖反转原则">Dependency Inversion Principle 依赖反转原则</a>
<ul>
<li class="toc-entry toc-h4"><a href="#例子-4">例子</a></li>
<li class="toc-entry toc-h4"><a href="#原则阐述-4">原则阐述</a></li>
</ul>
</li>
</ul>
</li>
<li class="toc-entry toc-h2"><a href="#solid视角下的设计模式">SOLID视角下的设计模式</a>
<ul>
<li class="toc-entry toc-h3"><a href="#举例srp与职责链模式">举例：SRP与职责链模式</a></li>
<li class="toc-entry toc-h3"><a href="#举例ocp与适配器模式">举例：OCP与适配器模式</a></li>
</ul>
</li>
<li class="toc-entry toc-h2"><a href="#参考">参考</a></li>
</ul>
    </div>

    <div id="markdown-content">
        <h2>
<a class="anchor" href="#-solid%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99-" aria-hidden="true"><span class="octicon octicon-link"></span></a> SOLID设计原则 </h2>

<p>本文介绍SOLID 5大设计原则，以及与设计模式的关系。</p>

<p>设计原则是进行软件系统设计、开发的原则，应用于两个层面：</p>
<ol>
  <li>组件层面：指导如何将代码组织成类、组件</li>
  <li>架构层面：指导如何将组件组织为软件系统</li>
</ol>

<p>本文只涉及“组件层面”。</p>

<p>使用设计原则的目的：提高代码复用性、可读性、可维护性。</p>

<h3 id="single-responsibility-principle-单一职责原则">
<a class="anchor" href="#single-responsibility-principle-%E5%8D%95%E4%B8%80%E8%81%8C%E8%B4%A3%E5%8E%9F%E5%88%99" aria-hidden="true"><span class="octicon octicon-link"></span></a>Single Responsibility Principle 单一职责原则</h3>

<h4 id="例子">
<a class="anchor" href="#%E4%BE%8B%E5%AD%90" aria-hidden="true"><span class="octicon octicon-link"></span></a>例子</h4>

<h5 id="问题描述"><b>问题描述</b></h5>

<p><img src="/assets/20230423-solid/srp-1.png" alt=""></p>

<p>某一个工资管理程序中有1个类Employee，包含了2个函数，对应的是2个不同的行为者：</p>
<ol>
  <li>GetSalaryReport（获取薪资报表）由财务部门确定规则，负责向CFO汇报</li>
  <li>GetWorkReport（获取假勤报表）由人力资源部门确定规则，负责向COO汇报</li>
</ol>

<p>GetSalaryReport和GetWorkReport都需要计算工作时长，程序员为了复用代码，会用同一个函数getRegularHours实现。</p>

<p>某一天，CFO团队需要修改工作时长计算方法，程序员修改时，没有注意到此函数被GetWorkReport使用，修改后经CFO团队测试后直接上线。之后COO团队仍在使用GetWorkReport函数，生成错误报表，最终会造成大量损失。</p>

<h5 id="问题分析"><b>问题分析</b></h5>

<p>问题的根源是将不同行为者依赖的代码强行拼凑在了一起。</p>

<h5 id="解决方案"><b>解决方案</b></h5>

<ol>
  <li>对于CFO、COO团队，对应使用2个类实现各自的业务功能，各自计算工作时长</li>
  <li>方案缺点：使用方需要处理2个类，而不是之前的一个，增加了使用成本</li>
</ol>

<p><img src="/assets/20230423-solid/srp-2.png" alt=""></p>

<h4 id="原则阐述">
<a class="anchor" href="#%E5%8E%9F%E5%88%99%E9%98%90%E8%BF%B0" aria-hidden="true"><span class="octicon octicon-link"></span></a><b>原则阐述</b>
</h4>

<p>阐述：每个类/组件只承担一个职责，只有一个被变更的原因，这个变更原因是由它负责的职责确定的。同时，此类/组件需要提供该职责的完整功能。</p>

<p>假设一个类负责多个职责，当有需求修改这个类时，有可能导致另一个类的功能发生故障。</p>

<p>目的：</p>
<ol>
  <li>实现高内聚、低耦合</li>
  <li>提高代码复用性、可读性、可维护性</li>
</ol>

<h3 id="open-closed-principle-开闭原则">
<a class="anchor" href="#open-closed-principle-%E5%BC%80%E9%97%AD%E5%8E%9F%E5%88%99" aria-hidden="true"><span class="octicon octicon-link"></span></a>Open Closed Principle 开闭原则</h3>

<h4 id="例子-1">
<a class="anchor" href="#%E4%BE%8B%E5%AD%90-1" aria-hidden="true"><span class="octicon octicon-link"></span></a>例子</h4>

<p>目标：设计一个财务报表系统，可以根据原始数据计算报表数据，并在Web上展示财务报表。</p>
<ol>
  <li>[一期需求]Web上展示的数据，滚动展示，且负值显示为红色</li>
  <li>[二期需求]打印数据时，使用黑白打印机打印，需要做分页逻辑，且每页上都有表头，需要展示页码，负值以括号展示</li>
</ol>

<p>分析：</p>

<p>良好的设计，代码复用性强；在新增功能时，只需要修改少量甚至不修改已有代码。</p>

<p>最终方案：</p>
<ol>
  <li>实现新功能，只需要增加PrintPresenter, PDFView类，不需要修改旧代码。</li>
  <li>依赖是单向的，且最终指向Interactor。也意味着Interactor是系统中最抽象的类，其他类的修改，都不会影响到它。</li>
</ol>

<p><img src="/assets/20230423-solid/ocp-1.png" alt=""></p>

<h4 id="原则阐述-1">
<a class="anchor" href="#%E5%8E%9F%E5%88%99%E9%98%90%E8%BF%B0-1" aria-hidden="true"><span class="octicon octicon-link"></span></a>原则阐述</h4>

<p>阐述：一个设计良好的类/组件应该在不需要修改现有代码的前提下就可以轻易被扩展。也就是对扩展Open，对修改Close。</p>

<p>对修改Close，意味着尽可能降低需求变化时对现有代码的修改量，甚至降低为0；这个目标是我们学习设计原则的根本目的。如果对原始需求的小小变动就需要对原有的软件系统进行大幅修改，这个设计一定是失败的。</p>

<p>目的：</p>
<ol>
  <li>让系统容易扩展，同时限制每次修改的影响范围。</li>
  <li>提高代码复用性、可读性、可维护性</li>
</ol>

<h3 id="liskov-substitution-principle-里氏替换原则">
<a class="anchor" href="#liskov-substitution-principle-%E9%87%8C%E6%B0%8F%E6%9B%BF%E6%8D%A2%E5%8E%9F%E5%88%99" aria-hidden="true"><span class="octicon octicon-link"></span></a>Liskov Substitution Principle 里氏替换原则</h3>

<h4 id="例子-2">
<a class="anchor" href="#%E4%BE%8B%E5%AD%90-2" aria-hidden="true"><span class="octicon octicon-link"></span></a>例子</h4>

<p>说明：</p>
<ol>
  <li>List定义了一组方法</li>
  <li>有两个好的实现的例子：LinkedList, ArrayList，他们完全按照接口定义的行为实现细节</li>
  <li>有两个不好的实现的例子CustomList</li>
</ol>

<p>List接口：</p>
<div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">var</span> <span class="n">OutOfBoundError</span> <span class="o">=</span> <span class="n">errors</span><span class="o">.</span><span class="n">New</span><span class="p">(</span><span class="s">"index out of bound"</span><span class="p">)</span>

<span class="k">type</span> <span class="n">List</span><span class="p">[</span><span class="n">T</span> <span class="n">any</span><span class="p">]</span> <span class="k">interface</span> <span class="p">{</span>
    <span class="c">// 如果index越界，返回OutOfBoundError.</span>
    <span class="n">GetByIndex</span><span class="p">(</span><span class="n">index</span> <span class="kt">int</span><span class="p">)</span> <span class="p">(</span><span class="n">T</span><span class="p">,</span> <span class="kt">error</span><span class="p">)</span>
    <span class="n">Length</span><span class="p">()</span> <span class="kt">int</span>
<span class="p">}</span>
</code></pre></div></div>

<p>坏例子1：改变了接口定义的行为</p>

<div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">func</span> <span class="p">(</span><span class="n">c</span> <span class="o">*</span><span class="n">CustomList</span><span class="p">[</span><span class="n">T</span><span class="p">])</span> <span class="n">GetByIndex</span><span class="p">(</span><span class="n">index</span> <span class="kt">int</span><span class="p">)</span> <span class="p">(</span><span class="n">T</span><span class="p">,</span> <span class="kt">error</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">var</span> <span class="n">zeroT</span> <span class="n">T</span>
    <span class="k">if</span> <span class="n">index</span> <span class="o">&lt;</span> <span class="m">0</span> <span class="o">||</span> <span class="n">index</span> <span class="o">&gt;=</span> <span class="nb">len</span><span class="p">(</span><span class="n">c</span><span class="o">.</span><span class="n">data</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">return</span> <span class="n">zeroT</span><span class="p">,</span> <span class="n">errors</span><span class="o">.</span><span class="n">New</span><span class="p">(</span><span class="s">"err occurred"</span><span class="p">)</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="n">c</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="n">index</span><span class="p">],</span> <span class="no">nil</span>
<span class="p">}</span>
</code></pre></div></div>

<p>坏例子2：改变了接口的语义</p>

<p>下述实现返回倒序的顺序。</p>
<div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">func</span> <span class="p">(</span><span class="n">c</span> <span class="o">*</span><span class="n">CustomList</span><span class="p">[</span><span class="n">T</span><span class="p">])</span> <span class="n">GetByIndex</span><span class="p">(</span><span class="n">index</span> <span class="kt">int</span><span class="p">)</span> <span class="p">(</span><span class="n">T</span><span class="p">,</span> <span class="kt">error</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">var</span> <span class="n">zeroT</span> <span class="n">T</span>
    <span class="k">if</span> <span class="n">index</span> <span class="o">&lt;</span> <span class="m">0</span> <span class="o">||</span> <span class="n">index</span> <span class="o">&gt;=</span> <span class="nb">len</span><span class="p">(</span><span class="n">c</span><span class="o">.</span><span class="n">data</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">return</span> <span class="n">zeroT</span><span class="p">,</span> <span class="n">OutOfBoundError</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="n">c</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="nb">len</span><span class="p">(</span><span class="n">c</span><span class="o">.</span><span class="n">data</span><span class="p">)</span><span class="o">-</span><span class="m">1</span><span class="o">-</span><span class="n">index</span><span class="p">],</span> <span class="no">nil</span>
<span class="p">}</span>
</code></pre></div></div>

<h4 id="原则阐述-2">
<a class="anchor" href="#%E5%8E%9F%E5%88%99%E9%98%90%E8%BF%B0-2" aria-hidden="true"><span class="octicon octicon-link"></span></a>原则阐述</h4>

<p>阐述：如果想用可替换的组件（子类、HTTP接口等）来构建软件系统，那么这些组件就必须遵循同一个约定，以便他们可以相互替换。</p>

<p>目的： 降低系统复杂性。</p>

<p>违反此原则的危害：</p>
<ol>
  <li>反直觉：使用方期望所有的子类行为是一致的。</li>
  <li>增加代码复杂度：如果子类行为不一致，可能需要不同的逻辑分支适配不同的行为，增加代码复杂度。</li>
</ol>

<h3 id="interface-segregation-principle-接口隔离原则">
<a class="anchor" href="#interface-segregation-principle-%E6%8E%A5%E5%8F%A3%E9%9A%94%E7%A6%BB%E5%8E%9F%E5%88%99" aria-hidden="true"><span class="octicon octicon-link"></span></a>Interface Segregation Principle 接口隔离原则</h3>

<h4 id="例子-3">
<a class="anchor" href="#%E4%BE%8B%E5%AD%90-3" aria-hidden="true"><span class="octicon octicon-link"></span></a>例子</h4>

<p>说明：</p>
<ol>
  <li>golang的标准库的interface都设计得很小</li>
  <li>以io接口为例，net.Conn实现了Reader/Writer/Closer, os.File实现了Reader/Writer/Closer/Seeker</li>
  <li>如果io只定义了包括Read/Write/Close/Seek四个方法的接口，那么net.Conn如果想使用这些接口，就需要实现自己不需要关心的方法。</li>
</ol>

<p>io相关接口：</p>
<div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c">// 读取最多len(p)个byte到p中；返回实际读取的byte数量，及error。</span>
<span class="k">type</span> <span class="n">Reader</span> <span class="k">interface</span> <span class="p">{</span>
    <span class="n">Read</span><span class="p">(</span><span class="n">p</span> <span class="p">[]</span><span class="kt">byte</span><span class="p">)</span> <span class="p">(</span><span class="n">n</span> <span class="kt">int</span><span class="p">,</span> <span class="n">err</span> <span class="kt">error</span><span class="p">)</span>
<span class="p">}</span>

<span class="c">// 写入p中的数据到io具体实现中中</span>
<span class="k">type</span> <span class="n">Writer</span> <span class="k">interface</span> <span class="p">{</span>
    <span class="n">Write</span><span class="p">(</span><span class="n">p</span> <span class="p">[]</span><span class="kt">byte</span><span class="p">)</span> <span class="p">(</span><span class="n">n</span> <span class="kt">int</span><span class="p">,</span> <span class="n">err</span> <span class="kt">error</span><span class="p">)</span>
<span class="p">}</span>

<span class="k">type</span> <span class="n">Closer</span> <span class="k">interface</span> <span class="p">{</span>
    <span class="n">Close</span><span class="p">()</span> <span class="kt">error</span>
<span class="p">}</span>

<span class="c">// 设置Read读取offset, 或Write函数写入offset</span>
<span class="k">type</span> <span class="n">Seeker</span> <span class="k">interface</span> <span class="p">{</span>
    <span class="n">Seek</span><span class="p">(</span><span class="n">offset</span> <span class="kt">int64</span><span class="p">,</span> <span class="n">whence</span> <span class="kt">int</span><span class="p">)</span> <span class="p">(</span><span class="kt">int64</span><span class="p">,</span> <span class="kt">error</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div></div>

<p>net包中的Conn是面向stream的网络连接接口。实现了Reader/Writer/Closer，未实现Seeker.</p>

<p>TCPConn和UDPConn均实现了Conn.</p>
<div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">type</span> <span class="n">Conn</span> <span class="k">interface</span> <span class="p">{</span>
    <span class="c">// Read reads data from the connection.</span>
    <span class="n">Read</span><span class="p">(</span><span class="n">b</span> <span class="p">[]</span><span class="kt">byte</span><span class="p">)</span> <span class="p">(</span><span class="n">n</span> <span class="kt">int</span><span class="p">,</span> <span class="n">err</span> <span class="kt">error</span><span class="p">)</span>
    <span class="c">// Write writes data to the connection.</span>
    <span class="n">Write</span><span class="p">(</span><span class="n">b</span> <span class="p">[]</span><span class="kt">byte</span><span class="p">)</span> <span class="p">(</span><span class="n">n</span> <span class="kt">int</span><span class="p">,</span> <span class="n">err</span> <span class="kt">error</span><span class="p">)</span>
    <span class="c">// Close closes the connection.</span>
    <span class="n">Close</span><span class="p">()</span> <span class="kt">error</span>

    <span class="c">// ...</span>
<span class="p">}</span>
</code></pre></div></div>

<p>os包的File表示一个文件描述符，实现了Reader/Writer/Closer/Seeker 4个接口。</p>
<div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c">// File represents an open file descriptor.</span>
<span class="k">type</span> <span class="n">File</span> <span class="k">struct</span> <span class="p">{</span>
    <span class="o">*</span><span class="n">file</span>
<span class="p">}</span>
</code></pre></div></div>

<h4 id="原则阐述-3">
<a class="anchor" href="#%E5%8E%9F%E5%88%99%E9%98%90%E8%BF%B0-3" aria-hidden="true"><span class="octicon octicon-link"></span></a>原则阐述</h4>

<p>阐述：尽量将臃肿庞大的接口拆分成较小的接口，让接口只包含使用方感兴趣的方法。从而使用方可以避免引入不需要的依赖。</p>

<h3 id="dependency-inversion-principle-依赖反转原则">
<a class="anchor" href="#dependency-inversion-principle-%E4%BE%9D%E8%B5%96%E5%8F%8D%E8%BD%AC%E5%8E%9F%E5%88%99" aria-hidden="true"><span class="octicon octicon-link"></span></a>Dependency Inversion Principle 依赖反转原则</h3>

<h4 id="例子-4">
<a class="anchor" href="#%E4%BE%8B%E5%AD%90-4" aria-hidden="true"><span class="octicon octicon-link"></span></a>例子</h4>

<p>设计一个登陆服务（DeviceService）：</p>
<ol>
  <li>DeviceService对外提供Login功能，封装了不同的登陆设备</li>
  <li>目前的设备包括DevicePhone, DeviceTL5两种，后续会新增更多类型</li>
</ol>

<p>初始实现，未使用interface：</p>
<ol>
  <li>DeviceService依赖DevicePhone, DeviceTL5两个具体实现</li>
  <li>使用Device的时候，根据私有变量deviceType判断使用哪个device实例</li>
  <li>增加设备时：需要修改DeviceService，增加一个DeviceXXX类</li>
</ol>

<p><img src="/assets/20230423-solid/dip-1.png" alt=""></p>

<div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">type</span> <span class="n">DevicePhone</span> <span class="k">struct</span> <span class="p">{</span>

<span class="p">}</span>

<span class="k">func</span> <span class="p">(</span><span class="n">d</span> <span class="o">*</span><span class="n">DevicePhone</span><span class="p">)</span> <span class="n">Login</span><span class="p">()</span> <span class="kt">error</span> <span class="p">{</span>
    <span class="n">logger</span><span class="o">.</span><span class="n">Println</span><span class="p">(</span><span class="s">"DevicePhone login"</span><span class="p">)</span>
    <span class="k">return</span> <span class="no">nil</span>
<span class="p">}</span>

<span class="k">type</span> <span class="n">DeviceTL5</span> <span class="k">struct</span> <span class="p">{</span>

<span class="p">}</span>

<span class="k">func</span> <span class="p">(</span><span class="n">d</span> <span class="o">*</span><span class="n">DeviceTL5</span><span class="p">)</span> <span class="n">Login</span><span class="p">()</span> <span class="kt">error</span> <span class="p">{</span>
    <span class="n">logger</span><span class="o">.</span><span class="n">Println</span><span class="p">(</span><span class="s">"DeviceTL5 login"</span><span class="p">)</span>
    <span class="k">return</span> <span class="no">nil</span>
<span class="p">}</span>

<span class="k">type</span> <span class="n">DeviceService</span> <span class="k">struct</span> <span class="p">{</span>
    <span class="n">deviceType</span> <span class="kt">string</span>
    <span class="n">devicePhone</span> <span class="o">*</span><span class="n">DevicePhone</span>
    <span class="n">deviceTL5</span> <span class="o">*</span><span class="n">DeviceTL5</span>
<span class="p">}</span>

<span class="k">func</span> <span class="p">(</span><span class="n">d</span> <span class="o">*</span><span class="n">DeviceService</span><span class="p">)</span> <span class="n">Login</span><span class="p">()</span> <span class="kt">error</span> <span class="p">{</span>
    <span class="k">switch</span> <span class="n">d</span><span class="o">.</span><span class="n">deviceType</span> <span class="p">{</span>
    <span class="k">case</span> <span class="s">"device_phone"</span><span class="o">:</span>
        <span class="k">return</span> <span class="n">d</span><span class="o">.</span><span class="n">devicePhone</span><span class="o">.</span><span class="n">Login</span><span class="p">()</span>
    <span class="k">case</span> <span class="s">"device_tl5"</span><span class="o">:</span>
        <span class="k">return</span> <span class="n">d</span><span class="o">.</span><span class="n">deviceTL5</span><span class="o">.</span><span class="n">Login</span><span class="p">()</span>
    <span class="k">default</span><span class="o">:</span>
        <span class="nb">panic</span><span class="p">(</span><span class="s">"invalid device_type"</span><span class="p">)</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>改进实现，使用interface：</p>
<ol>
  <li>DeviceService只依赖Device这个interface，不关心具体实现是哪个</li>
  <li>DevicePhone/DeviceTL5时Device的两个实现</li>
  <li>增加设备时，只需要增加DeviceXXX类（实现Device）</li>
</ol>

<p><img src="/assets/20230423-solid/dip-2.png" alt=""></p>

<div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">type</span> <span class="n">Device</span> <span class="k">interface</span> <span class="p">{</span>
    <span class="n">Login</span><span class="p">()</span> <span class="kt">error</span>
<span class="p">}</span>

<span class="k">type</span> <span class="n">DeviceService</span> <span class="k">struct</span> <span class="p">{</span>
    <span class="n">device</span> <span class="n">Device</span>
<span class="p">}</span>

<span class="k">func</span> <span class="p">(</span><span class="n">d</span> <span class="o">*</span><span class="n">DeviceService</span><span class="p">)</span> <span class="n">Login</span><span class="p">()</span> <span class="kt">error</span> <span class="p">{</span>
    <span class="k">return</span> <span class="n">d</span><span class="o">.</span><span class="n">device</span><span class="o">.</span><span class="n">Login</span><span class="p">()</span>
<span class="p">}</span>
</code></pre></div></div>

<h4 id="原则阐述-4">
<a class="anchor" href="#%E5%8E%9F%E5%88%99%E9%98%90%E8%BF%B0-4" aria-hidden="true"><span class="octicon octicon-link"></span></a>原则阐述</h4>

<p>阐述：
要面向接口编程，而不是面向实现编程。高层模块不应该依赖低层模块，两者都应该依赖其抽象；抽象不应该依赖细节，细节应该依赖抽象。</p>

<p>依赖倒置原则是实现开闭原则的重要途径之一，它降低了使用方与实现模块之间的耦合。由于在软件设计中，细节具有多变性，而抽象层则相对稳定，因此以抽象为基础搭建起来的架构要比以细节为基础搭建起来的架构要稳定得多。</p>

<p>目的：</p>
<ol>
  <li>降低类间的耦合性。</li>
  <li>提高系统的稳定性。</li>
  <li>减少并行开发引起的风险。</li>
  <li>提高代码的可读性和可维护性。</li>
</ol>

<p>命名由来：</p>

<p>以“例子”为例说明：之前底层实现（DeviceXXX）没有别的依赖，现在会依赖接口，这就是反转。</p>

<h2 id="solid视角下的设计模式">
<a class="anchor" href="#solid%E8%A7%86%E8%A7%92%E4%B8%8B%E7%9A%84%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F" aria-hidden="true"><span class="octicon octicon-link"></span></a>SOLID视角下的设计模式</h2>

<p>设计模式是软件领域特定问题的通用解决方案，所以会遵循SOLID。</p>

<h3 id="举例srp与职责链模式">
<a class="anchor" href="#%E4%B8%BE%E4%BE%8Bsrp%E4%B8%8E%E8%81%8C%E8%B4%A3%E9%93%BE%E6%A8%A1%E5%BC%8F" aria-hidden="true"><span class="octicon octicon-link"></span></a>举例：SRP与职责链模式</h3>

<p>说明：</p>
<ol>
  <li>以提供订购服务的Web服务为例，该服务包含若干HTTP API</li>
  <li>不同类的API需要不同的前置检查，如身份验证、数据验证、缓存等</li>
</ol>

<p>初始设计：</p>
<ol>
  <li>前置检查和业务代码写在一起，且前置检查放在一个函数里边</li>
  <li>遇到的问题：业务代码迅速变得很臃肿，且修改前置检查代码会影响所有接口</li>
</ol>

<p><img src="/assets/20230423-solid/srp-rc-1.png" alt=""></p>

<p>解决方案，使用职责链模式：</p>
<ol>
  <li>每项检查都独立实现为middleware，在框架层面集成，与业务代码解耦合</li>
  <li>每个middleware只负责一个职责，所以符合SRP。</li>
</ol>

<p><img src="/assets/20230423-solid/srp-rc-2.png" alt=""></p>

<h3 id="举例ocp与适配器模式">
<a class="anchor" href="#%E4%B8%BE%E4%BE%8Bocp%E4%B8%8E%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F" aria-hidden="true"><span class="octicon octicon-link"></span></a>举例：OCP与适配器模式</h3>

<p>说明：</p>
<ol>
  <li>以从不同来源获取骨片数据，计算分析报表，展示给用户的程序为例</li>
  <li>不同的数据来源方数据格式不尽相同，分析函数库只支持JSON特定格式的数据。</li>
  <li>修改分析函数库比较复杂，或者因为使用第三方服务根本无法修改，所以只能采用其他办法</li>
</ol>

<p><img src="/assets/20230423-solid/ocp-a-1.png" alt=""></p>

<p>解决方案，使用适配器模式：</p>
<ol>
  <li>为每一种数据格式写一个适配器类，将数据转化为分析函数库可以使用的格式</li>
  <li>新增数据格式时，由于不需要修改分析函数库，所以符合开闭原则</li>
  <li>下图是更为抽象的适配器模式的描述</li>
</ol>

<p><img src="/assets/20230423-solid/ocp-a-2.png" alt="">
<img src="/assets/20230423-solid/ocp-a-3.png" alt=""></p>

<h2 id="参考">
<a class="anchor" href="#%E5%8F%82%E8%80%83" aria-hidden="true"><span class="octicon octicon-link"></span></a>参考</h2>

<p>[1] 《架构整洁之道》</p>

<p>[2] <a href="https://refactoringguru.cn/design-patterns/catalog">设计模式</a></p>

<p>[3] <a href="https://zhuanlan.zhihu.com/p/268574641">细说 里氏替换原则</a></p>

<p>[4] <a href="https://www.cnblogs.com/hunternet/p/14646443.html">单一职责原则</a></p>

    </div>

</article>
      </div>
    </main>
  </body>
</html>